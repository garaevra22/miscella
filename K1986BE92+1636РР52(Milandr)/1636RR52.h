// ***********************************************************************************
// Микроконтроллер: 1986ВЕ92QI
// Файл:  1636RR52.h
// Модуль:  Работа с микросхемой Flash-памяти 1636РР52У1
// Компилятор:  ARM GCC Compiler из IDE Em::Blocks 2.30
// ***********************************************************************************

#ifndef __U_1636RR52
 #define __U_1636RR52

#include <stdint.h>
//***** Структуры для работы с записями(блоками) во флэш ****
	typedef struct
	{  uint8_t siz0; ///размер области данных в блоке
	uint8_t siz1;    ///дубль предыдущего поля
	uint8_t type;    ///тип блока, определяющий его стркутуру. Если 0 - стертый или дефектный.
	                 ///type = 0xff недопустим! Есть типы, для которых блок может быть только 1!
                     ///на флэш, e.g. управляющие последовательности. Могут быть и типы, для 
		     ///для которых допустимы цепочки блоков. 0 означает удаленный блок.
	uint8_t attrib;  ///атрибуты блока, e.g. 7-й бит - признак продолжения массива в
                     ///следующем блоке; 0 - последний блок, 1 -промежуточный. 6-й бит=1 - блок
                     ///продолжает заполняться, т.е. CRC еще не сформирован и длина 0x7f,
                     ///6-й бит=0 - заполнен.
                     ///В блоке защита при помощи CRC применяется к полям type, attrib и данным.
	} epromBlHd;
//***
	typedef struct //28.09.22  union
	{	epromBlHd Hdr;
		uint8_t Dat[124]; //28.09.22 128 Hdr + максимально возможное количество данных + CRC (2 байта);
	} epromBl;

    typedef union  //временный заголовок для модификации/стирания блоков
	{	epromBlHd Hdr;
		uint8_t Dat[4]; //28.09.22 128 Hdr + максимально возможное количество данных + CRC (2 байта);
	} epromThd;
//**** Настройки ****

// Контроллер SPI
#define U_1636RR52_SPI MDR_SSP2

// MOSI
#define U_1636RR52_MOSI_PORT MDR_PORTD
#define U_1636RR52_MOSI_PIN  PORT_Pin_6
#define U_1636RR52_MOSI_FUNC PORT_FUNC_ALTER;

// MISO
#define U_1636RR52_MISO_PORT MDR_PORTC
#define U_1636RR52_MISO_PIN  PORT_Pin_2
#define U_1636RR52_MISO_FUNC PORT_FUNC_OVERRID;

// SCLK
#define U_1636RR52_SCLK_PORT MDR_PORTC
#define U_1636RR52_SCLK_PIN  PORT_Pin_1
#define U_1636RR52_SCLK_FUNC PORT_FUNC_OVERRID;

// SS
#define U_1636RR52_SS_PORT MDR_PORTC
#define U_1636RR52_SS_PIN  PORT_Pin_0
#define U_1636RR52_SS_FUNC PORT_FUNC_OVERRID;

// Частота SCLK
// F_SCLK = PCLK / SSP_BRG / (CPSDVR * (1 + SCR))
// PCLK - частота тактирования периферии
///#define U_1636RR52_SSP_BRG SSP_HCLKdiv8   // 1,2,4,8,16,32,64,128
#define U_1636RR52_SSP_BRG SSP_HCLKdiv1  ///Переход на 4 МГц 8.01.21

#define U_1636RR52_SSP_SCR  = 9;   /// 9  Serial Clock Rate of регистра SSPCR0  1/(SCR + 1)

#define U_1636RR52_SSP_CPSDVSR 2;
///clock prescale divisor value of регистра SSPCPSR, итого 1*(9+1)*2=20
/*
--------------------------------------------------------------------------------------
Команда               Код команды    Частота     Байт   Байт      Байт      Всего
                                                 адреса фиктивных данных    байт
--------------------------------------------------------------------------------------
Read Array            03h 0000 0011  до 15 МГц   3      0         1       * 5 и выше
                      0Bh 0000 1011  до 100 МГц  3      1         1         6 и выше
--------------------------------------------------------------------------------------
Sector Erase          D8h 1101 1000  до 100 МГц  3      0         0       * 4
--------------------------------------------------------------------------------------
Chip Erase            60h 0110 0000  до 100 МГц  0      0         0       * 1
--------------------------------------------------------------------------------------
Byte Program          02h 0000 0010  до 100 МГц  3      0         1       * 5
--------------------------------------------------------------------------------------
Write Enable          06h 0000 0110  до 100 МГц  0      0         0       * 1
--------------------------------------------------------------------------------------
Write Disable         04h 0000 0100  до 100 МГц  0      0         0       * 1
--------------------------------------------------------------------------------------
Protect Sector        36h 0011 0110  до 100 МГц  3      0         0         4
--------------------------------------------------------------------------------------
Unprotect Sector      39h 0011 1001  до 100 МГц  3      0         0         4
--------------------------------------------------------------------------------------
Read Sector
Protection Register   3Ch 0011 1100  до 100 МГц  3      0         1         5
--------------------------------------------------------------------------------------
Read Status Register  05h 0000 0101  до 100 МГц  0      0         1       * 2
--------------------------------------------------------------------------------------
Write Status Register 01h 0000 0001  до 100 МГц  0      0         1         2
--------------------------------------------------------------------------------------
Reset                 F0h 1111 0000  до 100 МГц  0      0         1       * 2
--------------------------------------------------------------------------------------
Read ID устройства и
производителя         9Fh 1001 1111  до 100 МГц  0      0         2       * 3
--------------------------------------------------------------------------------------
*/

// **** Коды команд ****
// Read Array - чтение массива данных на частоте до 15 МГц
#define U_1636RR52_CMD_READ_ARRAY_15 0x03
// Read Array - чтение массива данных на частоте до 100 МГц
#define U_1636RR52_CMD_READ_ARRAY_100 0x0B
// Sector Erase  - Стирание сектора
#define U_1636RR52_CMD_SECTOR_ERASE 0xD8
#define U_1636RR52_CMD_L_SECTOR_ERASE 4
// Chip Erase  - Стирание всей памяти
#define U_1636RR52_CMD_CHIP_ERASE 0x60
// Byte Program - Программирование байта
#define U_1636RR52_CMD_BYTE_PROGRAM 0x02
#define U_1636RR52_CMD_L_BYTE_PROGRAM 5
// Write Enable - Разрешение записи
#define U_1636RR52_CMD_WRITE_ENABLE 0x06
#define U_1636RR52_CMD_L_WRITE_ENABLE 1
// Write Disable - Запрет записи
#define U_1636RR52_CMD_WRITE_DISABLE 0x04
#define U_1636RR52_CMD_L_WRITE_DISABLE 1
// Protect Sector - Защита сектора
#define U_1636RR52_CMD_PROTECT_SECTOR 0x36
#define U_1636RR52_CMD_L_PROTECT_SECTOR 4
// Unprotect Sector - Снятие защиты сектора
#define U_1636RR52_CMD_UNPROTECT_SECTOR 0x39
#define U_1636RR52_CMD_L_UNPROTECT_SECTOR 4
// Read Sector Protection Register - Чтение регистра защиты сектора
#define U_1636RR52_CMD_READ_SECTOR_PROTECTION_REGISTER 0x3C
#define U_1636RR52_CMD_L_READ_SECTOR_PROTECTION_REGISTER 5
// Read Status Register - Чтение регистра статуса
#define U_1636RR52_CMD_READ_STATUS_REGISTER 0x05
#define U_1636RR52_CMD_L_READ_STATUS_REGISTER 2
// Write Status Register - Запись регистра статуса
#define U_1636RR52_CMD_WRITE_STATUS_REGISTER 0x01
#define U_1636RR52_CMD_L_WRITE_STATUS_REGISTER 2
// Reset - Сброс
#define U_1636RR52_CMD_RESET  0xF0
#define U_1636RR52_CMD_L_RESET  2
// Read ID - Чтение ID кодов производителя и микросхемы
#define U_1636RR52_CMD_READ_ID 0x9F
#define U_1636RR52_CMD_L_READ_ID 3


// **** Биты регистра статуса ****

//  0 Бит состояния готовности устройства (R)
//  0 - микросхема готова
//  1 - микросхема занята  внутренней операцией
#define U_1636RR52_SR_RDY_BSY 0x01

//  1 Бит состояния доступа в микросхему (R)
//  0 - микросхема  не доступна  для записи (по умолчанию)
//  1 - микросхема доступна для записи
#define U_1636RR52_SR_WEL  0x02

//  3:2 Состояние защищенности секторов  (R)
//  00 - Все сектора не защищены (состояние всех регистров защиты сектора логический ноль)
//  01 - Некоторые сектора защищены. Чтение индивидуальных регистров защиты секторов позволяет определить, какие сектора защищены
//  10 - Зарезервированы для будущего использования
//  11 - сектора защищены (состояние всех регистров защиты секторов логическая единица – по умолчанию)
#define U_1636RR52_SR_SWP  0x0C

//  5 Ошибка стирания/записи  (R)
//  0 - Операция стирания или записи завершилась успешно
//  1 - Обнаружена ошибка во время операции записи или стирания
#define U_1636RR52_SR_EPE  0x20

//  6 Разрешение сброса (R/W)
//  0 - Команда сброса запрещена (по умолчанию)
//  1 - Команда сброса разрешена
#define U_1636RR52_SR_RSTE 0x40

//  7 Блокировка регистров защиты сектора   (R/W)
//  0 - Регистры защиты сектора не заблокированы (по умолчанию)
//  1 - Регистры защиты сектора заблокированы
#define U_1636RR52_SR_SPRL 0x80


// Инициализация

void U_1636RR52_Init (void);

// **** Команды *****
// Чтение 4 байт данных, начиная с заданного адреса, на частоте до 15 МГц
uint32_t U_1636RR52_Read_Word (uint32_t addr);
// Чтение массива данных на частоте до 15 МГц
uint32_t U_1636RR52_Read_Array_15 (uint32_t addr, uint8_t* dst, uint32_t Count);
// Чтение массива данных на частоте до 100 МГц
uint32_t U_1636RR52_Read_Array_100 (uint32_t addr, uint8_t* dst, uint32_t Count);
// Стирание сектора
uint32_t U_1636RR52_Sector_Erase (uint32_t Sector);
// Стирание всей памяти
uint32_t U_1636RR52_Chip_Erase (void);
// Программирование байта
void U_1636RR52_Byte_Program (uint32_t addr, uint8_t value);
// Программирование блока данных
void U_1636RR52_Block_Program (uint32_t addr, uint8_t* Src, uint32_t Count);
// Разрешение записи
void U_1636RR52_Write_Enable (void);
// Запрет записи
void U_1636RR52_Write_Disable (void);
// Защита сектора
uint32_t U_1636RR52_Protect_Sector (uint32_t addr);
// Снятие защиты сектора
//mine uint32_t
void U_1636RR52_Unprotect_Sector (uint32_t addr);
// Чтение регистра защиты сектора
uint32_t U_1636RR52_Read_Sector_Protection_Register (uint32_t addr);
// Чтение регистра статуса
uint32_t U_1636RR52_Read_Status_Register (void);
// Запись регистра статуса
void U_1636RR52_Write_Status_Register (uint8_t status);
// Сброс
void U_1636RR52_Reset (void);
// Чтение ID кодов производителя и микросхемы
uint32_t U_1636RR52_Read_ID (void);

//++++++++++++++++++++
///------- функции для работы с блоками из флэш -------
///поиск очередного неудаленного блока для чтения и формирование смещения до следующего
// return 1; признак "найден блок"
//return -1; ошибочная точка для начала поиска или просто пустая флэш!
//return 0; практически до конца 1636 нет нестертых блоков, т.е. все забито удаленными
int16_t seek4Blk2R(uint32_t *Offset, uint32_t *NxtOff);
///считать тело (данные) блока в Buf1636r
int16_t rdBlk(uint32_t BlOff, uint16_t C); //При ошибке CRC return -1
//--------------------------
///поиск начальной точки для записи нового блока
//модифицирует uint32_t wrBlOff -смещение в байтах до начала блока
//перед записью. Начальное wrBlOff лучше сделать 0
//возврат: 1 выход на свободную область, 0 или (-1) - места не осталось
 int16_t seekFree(void);
 //------------------------
 ///Запись нового блока в EEPROM со смещения wrBlOff из буфера Buf1636w
//Buf1636w должен быть заполнен, кроме CRC!
//модифицирует uint32_t wrBlOff - смещение в байтах до начала блока
//после записи. До этого считает CRC. Делает контрольное считывание!
//возврат: 1 OK, -1  нет совпадения при контрольном считывании.
 int16_t wrBlk2Free(void);
//-------------------------
///Запись/модификация заголовка блока EEPROM со смещения BlOff из буфера Hdr
//e.g. для удаления блока или завершения записи "временного" (пополняемого) блока
//NS - позволяет не перезаписывать размер
void mdfBlkHdr(uint32_t BlOff, epromThd *Hdr, uint16_t NS);
///Замена блока заданного типа на аналогичный с новым содержимым ("перезапись")
//старый стирается (type = 0), новый пишется за последним занятым блоком
//задействованы Buf1636w, Buf1636r; // write/read, и tmpHdr;
//(заголовок для стирания старого блока). Если rdBlOff!=0, то поиск стартует с этой точки!
//wrBlOff используется и модифицируется!.
  int16_t rplceBlk(uint8_t type, uint8_t attrib);
//++++++++++++++++++++
#endif


